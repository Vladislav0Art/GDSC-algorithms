\Subsection{Hash table with Sliding Window}

\begin{problem}

    Given an integer array $a$ and an integer $k$, return the number of \textbf{good subarrays} of $a$.

    A \textbf{good array} is an array where the number of different (distinct) integers in that array is exactly $k$. A subarray is a \textbf{contiguous part} of an array.

    For example, $[1, 2, 3, 1, 2]$ has $3$ different integers: $1, 2, 3$.

    Asymptotics: $O(n)$ in time and space. \newline


    \underline{Note}: you can solve this problem on LeetCode here \href{https://leetcode.com/problems/subarrays-with-k-different-integers/description/}{992. Subarrays with K Different Integers}.

\end{problem}

\begin{example}

    1. $a = [1,2,1,2,3]$, $k = 2$, the answer will be $7$, the good subarrays are:

    $[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]$.\newline

    2. $a = [1,2,1,3,4]$, $k = 3$, the answer will be $3$, the good subarrays are:

    $[1,2,1,3], [2,1,3], [1,3,4]$.

\end{example}

% \begin{solution}

% Idea: $exactly(k) = atMost(k) - atMost(k-1)$, thus let's count the number of subarrays with at most $k$ distinct numbers and the number of subarrays with at most $k-1$ distinct numbers.

% % In order to do that we need to keep the number of distinct numbers $cnt$ in a sliding window of a variable length, while $cnt \leq k$ the


% \begin{lstlisting}[language=C++]
% int subarraysWithAtMostKDistinct(vector<int>& nums, int k) {
%     unordered_map<int, int> counts;
%     int i = 0;
%     int cnt = 0;
%     int result = 0;

%     for (int j = 0; j < nums.size(); ++j) {
%         if (counts[nums[j]]++ == 0) {
%             ++cnt;
%         }

%         if (cnt <= k) {
%             result += (j - i + 1);
%         }

%         while (i <= j && cnt > k) {
%             --counts[nums[i]];
%             if (counts[nums[i]] == 0) {
%                 --cnt;
%             }
%             ++i;

%             if (cnt == k) {
%                 result += (j - i + 1);
%             }
%         }
%     }

%     return result;
% }

% int subarraysWithKDistinct(vector<int>& nums, int k) {
%     int a = subarraysWithAtMostKDistinct(nums, k);
%     int b = subarraysWithAtMostKDistinct(nums, k - 1);

%     return a - b;
% }
% \end{lstlisting}

% \end{solution}